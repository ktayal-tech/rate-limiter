/**
 * @file Sliding Window Rate Limiter
 * @description Implements a sliding window rate limiting algorithm to control the number of requests within a specified time window. Uses Redis to store request timestamps in a list, removing expired entries outside the window and allowing/denying new requests based on the configured limit.
 */

import { IRateLimiter } from "../interfaces/rate-limiter.js";
import { RedisClient } from "../storage/redis.js";
import fs from "fs";
import path from "path";

class SlidingWindowRateLimiter implements IRateLimiter {

	constructor(
		public requestLimitPerWindow: number,
		public windowSizeInMS: number
	) {}
    
	/**
	 * Generates a unique rate limit key based on user ID or IP address.
	 * @param userId - Optional user ID to identify the user
	 * @param ipAddress - IP address of the client as fallback identifier
	 * @returns A unique key for rate limit tracking in the format 'RATE_LIMIT_<identifier>'
	 */
	public generateKey(userId: number | undefined, ipAddress: string): string {
		return `RATE_LIMIT_${userId ? userId : ipAddress}`;
	}

	/**
	 * Determines whether a request should be allowed based on the sliding window rate limit.
	 * 
	 * This method implements the sliding window algorithm:
	 * 1. Removes timestamps outside the window from Redis using LUA script for atomicity
	 * 2. Checks if the current request count is below the limit
	 * 3. Adds the current timestamp if the limit is not reached
	 * 
	 * @param key - The rate limit key (typically generated by generateKey)
	 * @returns true if the request should proceed, false if it exceeds the rate limit
	 * Falls back to ALLOW_REQUESTS_IF_REDIS_DOWN environment variable if Redis is unavailable, by default not allowing the request.
	 */
	public async shouldProceed(key: string): Promise<boolean> {
		const redis = await RedisClient.getInstance();
		if (!(await redis.ping())) {
			return process.env.ALLOW_REQUESTS_IF_REDIS_DOWN === 'true' || false;
		}
		const exists = await redis.exists(key);
		if (!exists) {
			await redis.rpush(key, Date.now().toString());
		} else {
			/* Approach 1 (without atomicity)
            const now = Date.now();
			const timestamps = await redis.lrange(key, 0, -1);

			//finding first non-expired index
			let firstValidIndex = 0;
			for (let i = 0; i < timestamps.length; i++) {
				const ts = Number(timestamps[i]);
				if (now - ts <= this.windowSizeInMS) {
					firstValidIndex = i;
					break;
				}
				firstValidIndex = i + 1;
			}

			//trimming expired entries in one command
			if (firstValidIndex > 0) {
				// keep elements from firstValidIndex to end
				await redis.ltrim(key, firstValidIndex, -1);
			}

			const currentSize = timestamps.length - firstValidIndex;
			if (currentSize < this.requestLimitPerWindow) {
				await redis.rpush(key, now.toString());
				return true;
			}
			return false;*/

			// Approach 2 (with atomicity using LUA script)
			const luaScriptPath = path.join(
				__dirname,
				"../scripts/lua/should-proceed.lua"
			);
			const luaScript = fs.readFileSync(luaScriptPath, "utf8");
			const luaScriptSHA = await redis.loadScript(luaScript);
			const result = await redis.executeLuaScript(
				luaScriptSHA,
				[key],
				[
					Date.now().toString(),
					this.windowSizeInMS.toString(),
					this.requestLimitPerWindow.toString(),
				]
			);
			return result === 1;
		}
		return true;
	}

	/**
	 * Calculates the number of requests remaining within the current window.
	 * 
	 * This method uses a LUA script to atomically:
	 * 1. Remove expired timestamps from the list
	 * 2. Count valid requests in the current window
	 * 3. Return the remaining quota
	 * 
	 * @param key - The rate limit key (typically generated by generateKey)
	 * @returns The number of requests remaining before hitting the limit
	 * @returns Number.MAX_SAFE_INTEGER if Redis is unavailable
	 */
	public async getRemainingRequestsQuota(key: string): Promise<number> {
		const redis = await RedisClient.getInstance();
		if (!(await redis.ping())) {
			return Number.MAX_SAFE_INTEGER;
		}
		/* Approach 1 (without atomicity)
        
        const curentTimestamp = Date.now();
		const timestamps = await redis.lrange(key, 0, -1);
		//finding first non-expired index
		let firstValidIndex = 0;
		for (let i = 0; i < timestamps.length; i++) {
			const ts = Number(timestamps[i]);
			if (curentTimestamp - ts <= this.windowSizeInMS) {
				firstValidIndex = i;
				break;
			}
			firstValidIndex = i + 1;
		}

		//trimming expired entries in one command
		if (firstValidIndex > 0) {
			// keep elements from firstValidIndex to end
			await redis.ltrim(key, firstValidIndex, -1);
		}

		const currentSize = timestamps.length - firstValidIndex;
		return Math.max(this.requestLimitPerWindow - currentSize, 0);
        */
		// Approach 2 (with atomicity using LUA script)
		const luaScriptPath = path.join(
			__dirname,
			"../scripts/lua/get-remaining-requests.lua"
		);
		const luaScript = fs.readFileSync(luaScriptPath, "utf8");
		const luaScriptSHA = await redis.loadScript(luaScript);
		const result = (await redis.executeLuaScript(
			luaScriptSHA,
			[key],
			[
				Date.now().toString(),
				this.windowSizeInMS.toString(),
				this.requestLimitPerWindow.toString(),
			]
		)) as number;
		return result;
	}

	/**
	 * Retrieves the configured rate limit (requests per window).
	 * @returns The maximum number of requests allowed per window
	 */
	public getRateLimit(): number {
		return this.requestLimitPerWindow;
	}
}

export { SlidingWindowRateLimiter };